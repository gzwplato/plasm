# About Play Assembler

I don't know much about processor design. I have read a little (compared to the enormous quantity of lecture there is on the subject), and haven't done much assembler programming.
I have been doing third generation languages most of my studying and working life, and roughly have an idea to what underlying assembler the compiler generally converts code.
Recently all the hype is about GPU's and FGPU's, but there's also still being work done on multi-code machines, and even the old machines like 68K or 6502 based machines or even old main-frames.

And still, knowing a (tiny!) bit about 8080 and x86 op-codes, the difference between written assembler instructions, and the effective stream of byte-codes always intrigued me.
Not only how they translate, and that a final assembler is still quite a hefty program in itself, but also how in the beginning of it all a systems-designer must have thought about which meaning to bestow onto which combination of bit-values, either to make the maze of silicon lanes more straight-forward, or to hide as little as micro-code as possible later on.
Then reading up on ARM and techniques used by modern CPU's to make things move faster, such as on-die cache, hyper-threading and branch prediction, I can't help but feel there's been a bit of cruft amassing into the only-growing set of machine instructions and what a grand re-design from the bottom up could provide in benefits.

I don't pretend to have enough knowledge in the field to make a proposition that would benifit a large audience and could serve as a new lighted path for us all to go forward on, but I am none the less curious if I were able to design something clean and usable that serves the goals currently required to be met, and avoids the pitfalls and encumbrances the current solutions suffer.
This while also avoiding to slip into bouts of tunnel-vision and have recollection of current systems influence a new design too much, inheriting their shortcomings and perhaps closing avenues for innovation. But this might be where my lack of knowledge in the field may come in handy.

But there is also an 'other side' to have a look at. A typical scenario, the machine code itself is generated by a last step of a compiler tool chain, and is result by an optimization effort, and before that an effort to find the best suitable use of available registers.
This overlaps with the effort of mapping named registers to the available actual registers when doing branch prediction and/or hyper threading.

So there it is. To get things going I wanted to have something to work with, so build this first as a platform to perhaps start attempts at binary instruction encoding from. Hope you like it.
